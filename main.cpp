#include <iostream>

// Perceptron class
class Perceptron {
private:
    int dimention;
    double* weights;
    double theta;
    double learningRate;
    const double bias = 1.0;

    // Função que calcula o 'dot product' foi implementada dessa maneira
    // Para lidar com o peso do bias estar contido no array de pesos.
    inline double dot_product(int index, const int* dataset) {
        int t_index = index * dimention;
        double dotp = 0.0;
        for (int i = 0; i < dimention; ++i) {
            dotp += weights[i] * dataset[t_index++];
        }
        return dotp + bias * weights[dimention];
    }

    // Função que atualisa os pesos.
    inline bool ch_weights(int OUT, int TARGET, int index, const int* dataset) {
        if (OUT == TARGET) {
            return false;
        }
        int t_index = index * dimention;
        for (int i = 0; i < dimention; ++i) {
            weights[i] += learningRate * TARGET * dataset[t_index++];
        }
        weights[dimention] += learningRate * TARGET;
        return true;
    }

    // Função de ativação
    [[nodiscard]] inline int act_func(double y_in) const {
        if (y_in > theta) {
            return 1;
        }
        if (y_in >= theta - 1) {
            return 0;
        }
        return -1;
    }

    // Loop interno do código de treinamento.
    // Ele retorna se o peso foi atualizado ou não.
    // Ele é chamado dento do while do loop externo.
    bool i_train(int dataset_size, int* dataset, int* target) {
        int a_limit = dataset_size / dimention;
        bool wchanged = false;
        for (int i = 0; i < a_limit; ++i) {
            double NET = dot_product(i, dataset);
            int OUT = act_func(NET);
            wchanged |= ch_weights(OUT, target[i], i, dataset);
        }
        return wchanged;
    }

public:

    Perceptron(int dimention, double learningRate, double theta)
            : dimention(dimention), learningRate(learningRate), theta(theta), weights(new double[dimention + 1]{}) {}

    ~Perceptron() {
        delete[] weights;
    }

    // Loop externo do código de treinamento.
    void train(int dataset_size, int* dataset, int* target) {
        while (i_train(dataset_size, dataset, target)) {}
    }

    // Função para predizer o resultado.
    int predict(const int* dataset) {
        double NET = 0.0;
        for (int i = 0; i < dimention; ++i) {
            NET += weights[i] * dataset[i];
        }
        return act_func(NET + bias * weights[dimention]);
    }


    void print_weights() {
        for (int i = 0; i < dimention; ++i) {
            std::cout << "w" << i << " = " << weights[i] << '\n';
        }
        std::cout << "w_bias = " << weights[dimention] << '\n';
    }
};


int main() {

    std::cout << "Teste com OR: " << std::endl;

    int input[] = { 1, 1, 1, 0, 0, 1, 0, 0 };
    int target[] = { 1, 1, 1, -1 };
    int size = 8;

    double learningrate = 1.0;
    double theta = 0.2;
    int dimention = 2;

    auto* p = new Perceptron(dimention, learningrate, theta);
    p->print_weights();

    p->train(size, input, target);
    p->print_weights();

    delete p;

    std::cout << std::endl;
    std::cout << "Teste com letras: " << std::endl;

    int lput[] = {
            -1,-1,1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,1,/*1,-1,-1,-1,-1,-1,-1,*/
            1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,1,1,1,-1,/*-1,1,-1,-1,-1,-1,-1,*/
            -1,-1,1,1,1,1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,1,1,-1,/*-1,-1,1,-1,-1,-1,-1,*/
            1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,1,1,1,1,-1,-1,/*-1,-1,-1,1,-1,-1,-1,*/
            1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,/*-1,-1,-1,-1,1,-1,-1,*/
            -1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,/*-1,-1,-1,-1,-1,1,-1,*/
            1,1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,1,/*-1,-1,-1,-1,-1,-1,1,*/
            -1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,/*1,-1,-1,-1,-1,-1,-1,*/
            1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,-1,/*-1,1,-1,-1,-1,-1,-1,*/
            -1,-1,1,1,1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,/*-1,-1,1,-1,-1,-1,-1,*/
            1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,1,1,1,-1,-1,/*-1,-1,-1,1,-1,-1,-1,*/
            1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,/*-1,-1,-1,-1,1,-1,-1,*/
            -1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,/*-1,-1,-1,-1,-1,1,-1,*/
            1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1,1,-1,/*-1,-1,-1,-1,-1,-1,1,*/
            -1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,1,/*1,-1,-1,-1,-1,-1,-1,*/
            1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,1,1,1,-1,/*-1,1,-1,-1,-1,-1,-1,*/
            -1,-1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,/*-1,-1,1,-1,-1,-1,-1,*/
            1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,1,1,1,1,-1,-1,/*-1,-1,-1,1,-1,-1,-1,*/
            1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,-1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,/*-1,-1,-1,-1,1,-1,-1,*/
            -1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,/*-1,-1,-1,-1,-1,1,-1,*/
            1,1,1,-1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,1/*-1,-1,-1,-1,-1,-1,1*/


    };
    int ltarget[] {1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1};
    auto *pl = new Perceptron(63, 0.05, 0.5);
    pl->print_weights();
    std::cout << std::endl;
    pl->train(1323, lput, ltarget);
    pl->print_weights();
    int a1[] = {-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,1,1,1,1,1,1,1}; //é A, ou seja, esperamos que o predict seja 1.
    int not_a1[] = {1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,-1}; // não é A, ou seja, esperamos que o predict seja -1.
    int a2[] = {-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1};
    int not_a2[] = {1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,1,1,1,-1,-1};

    std::cout << std::endl;
    std::cout << "Teste do predict: " << std::endl;

    std::cout << pl->predict(a1) << std::endl;
    std::cout << pl->predict(not_a1) << std::endl;
    std::cout << pl->predict(a2) << std::endl;
    std::cout << pl->predict(not_a2) << std::endl;


    delete pl;
}